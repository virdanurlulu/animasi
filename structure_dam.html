<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Explosion Shock Wave Impact on Buildings (CSV, IC1–IC7, Resume)</title>
  <style>
    body { background: #f8fafc; margin: 0; padding: 0; }

    #scene{
      position: relative;
      width: 900px; height: 340px;
      margin: 40px auto 20px auto;
      background: #e5e7eb;
      border-radius: 14px;
      overflow: hidden;
      box-shadow: 0 2px 20px #0002;
    }

    .building{
      position: absolute;
      bottom: 45px;
      border-radius: 5px;
      box-shadow: 0 2px 8px #0003;
      transition: all 0.7s cubic-bezier(.85,-0.05,.43,1.09);
      will-change: transform, opacity, filter;
    }
    .building.small  { left: 350px; width: 40px; height: 50px;  background: #38bdf8; }
    .building.medium { left: 490px; width: 50px; height: 85px;  background: #2563eb; }
    .building.tall   { left: 670px; width: 55px; height: 145px; background: #0f172a; }

    .window{
      position: absolute;
      background: #fff;
      border-radius: 2px;
      border: 1px solid #b4b4b4;
      transition: background 0.7s, opacity 0.7s, border-color 0.7s;
    }

    #explosion{
      position: absolute; left: 110px; bottom: 65px;
      width: 40px; height: 40px; z-index: 10;
      background: radial-gradient(circle at 55% 60%, #ffd600 35%, #ff7300 70%, transparent 90%);
      border-radius: 50%;
      box-shadow: 0 0 50px 10px #ffbf00aa;
      border: 3px dashed #ffa500;
      animation: pulse 1.1s infinite linear;
    }
    @keyframes pulse{
      0%   { box-shadow: 0 0 30px 5px #ffe066aa; }
      100% { box-shadow: 0 0 60px 20px #ffe06600; }
    }

    #ground{
      position: absolute; left: 0; bottom: 0;
      width: 100%; height: 70px;
      background: linear-gradient(#b45309 60%, #fde68a 90%);
      border-radius: 0 0 90px 60px / 0 0 80px 50px;
      z-index: 0;
    }

    /* WAVE (driven via Web Animations API) */
    .wave{
      position: absolute;
      left: 125px; bottom: 85px;
      z-index: 2;
      border-radius: 50%;
      background: radial-gradient(circle, #ffa60099 0%, #ff1744bb 60%, #6d28d9aa 95%, transparent 100%);
      pointer-events: none;
      opacity: 0.83;

      width: 40px; height: 40px;
      margin-left: -20px; margin-bottom: -20px;
    }

    /* ===== Damage visuals (IC classes for building base look) ===== */
    .dIC1 { filter: saturate(0.98) brightness(0.99); }
    .dIC2 { filter: saturate(0.94) brightness(0.97); }
    .dIC3 { background: linear-gradient(#fb7185 75%, #fff 100%) !important; opacity: 0.80; }
    .dIC4 { background: linear-gradient(#ef4444 80%, #fff 100%) !important; opacity: 0.65; }
    .dIC5 { background: linear-gradient(#b91c1c 85%, #fff 100%) !important; opacity: 0.45; }
    .dIC6 { background: linear-gradient(#7f1d1d 90%, #fff 100%) !important; opacity: 0.30; }
    .dIC7 { background: linear-gradient(#450a0a 92%, #fff 100%) !important; opacity: 0.22; }

    .cracked{
      background: repeating-linear-gradient(-45deg, #d1d5db 0px, #d1d5db 3px, #fff 3px, #fff 8px) !important;
    }
    .window.broken{ background: #bdbdbd !important; opacity: 0.22; border-color: #a855f7; }
    .window.framebroken{ border-color: #b91c1c !important; }

    .hit{ animation: shake 0.6s; }
    @keyframes shake{
      0%{ transform: translateX(0);}
      20%{ transform: translateX(-7px);}
      40%{ transform: translateX(9px);}
      60%{ transform: translateX(-5px);}
      80%{ transform: translateX(5px);}
      100%{ transform: translateX(0);}
    }

    .effect-label{
      position: absolute; left: 0; right:0; bottom: 100%;
      text-align:center;
      font-size:1.02em;
      color:#b91c1c;
      background: #fff3;
      border-radius: 7px;
      padding: 3px 0 1px 0;
      opacity: 0;
      transition: opacity 0.7s;
      pointer-events: none;
      font-weight: 650;
      z-index: 30;
    }
    .show-label{ opacity: 1; }

    .credit{
      text-align: center;
      font-size: 0.98em;
      color: #64748b;
      margin-top: 8px;
      font-style: italic;
      letter-spacing: 0.03em;
      user-select: none;
    }

    #controls{
      width: 900px;
      margin: 0 auto 10px auto;
      background: #ffffff;
      border-radius: 12px;
      padding: 12px 14px;
      box-shadow: 0 2px 16px #0001;
      font-family: sans-serif;
    }
    #controls .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    #controls label{ font-size: 13px; color:#0f172a; }
    #controls input[type="file"]{ width: 280px; }
    #controls select, #controls input[type="number"]{
      padding:6px 8px;
      border-radius:8px;
      border:1px solid #cbd5e1;
    }
    #controls .hint{
      font-size: 12px;
      color:#64748b;
      margin-top:8px;
      line-height:1.35;
    }
    #controls .pill{
      display:inline-block;
      padding:4px 10px;
      border-radius:999px;
      background:#0f172a;
      color:#fff;
      font-size:12px;
    }

    .btn{
      padding:8px 18px;
      font-size:1em;
      border-radius:8px;
      border:1px solid #cbd5e1;
      background:#fff;
      cursor:pointer;
    }
    .btn:disabled{ opacity:0.6; cursor:not-allowed; }
    .toggle{ display:flex; align-items:center; gap:8px; }

    /* ===== NEW: Falling glass + rubble (continuous intensity by Po) ===== */
    .glassShard{
      position:absolute;
      width:6px; height:10px;
      background: linear-gradient(#e2e8f0, #94a3b8);
      border-radius: 2px;
      box-shadow: 0 1px 3px #0004;
      opacity: 0.95;
      z-index: 20;
      pointer-events:none;
      will-change: transform, opacity;
    }
    @keyframes glassFall{
      0%   { transform: translate(0,0) rotate(0deg); opacity:0.95; }
      70%  { opacity:0.9; }
      100% { transform: translate(var(--dx), var(--dy)) rotate(var(--rot)); opacity:0; }
    }

    .rubble{
      position:absolute;
      left:0; right:0;
      bottom:0;
      height:18px;
      background: repeating-linear-gradient(135deg, #64748b 0px, #64748b 6px, #475569 6px, #475569 12px);
      border-radius: 10px 10px 4px 4px;
      opacity: 0;
      transform: translateY(6px);
      transition: opacity .6s, transform .6s;
      z-index: 6;
      pointer-events:none;
      will-change: opacity, transform;
    }
    .rubble.show{
      opacity: 0.95;
      transform: translateY(0);
    }

    /* hooks (kept for readability / future extensions) */
    .collapse6{}
    .collapse7{}
    .disappear{ opacity:0.12; }
  </style>
</head>

<body>
  <h2 style="text-align:center; font-family:sans-serif; color:#0f172a; margin-bottom:10px;">
    Explosion Shock Wave Impact on Buildings (CSV, IC1–IC7, Resume)
  </h2>

  <div id="controls">
    <div class="row">
      <label><b>CSV:</b></label>
      <input type="file" id="csvInput" accept=".csv">

      <label><b>Model:</b></label>
      <select id="modelSel">
        <option value="follow_csv">Follow poModel (if exists)</option>
        <option value="crowl">Crowl (po_crowl)</option>
        <option value="alonso">Alonso (po_alonso)</option>
        <option value="sadovski">Sadovski (po_sadovski)</option>
      </select>

      <label><b>Wave duration (ms):</b></label>
      <input type="number" id="waveMs" value="3400" min="800" step="100">

      <span class="pill" id="status">No CSV loaded</span>
    </div>

    <div class="row" style="margin-top:10px;">
      <button class="btn" onclick="startBlast()" id="startBtn">▶️ Start / Resume</button>
      <button class="btn" onclick="stopBlast()" id="stopBtn" disabled>⏸️ Stop (Freeze)</button>
      <button class="btn" onclick="resetScene(true)" id="resetBtn">⏹️ Reset</button>

      <div class="toggle" style="margin-left:auto;">
        <input type="checkbox" id="autoRewindToggle" checked>
        <label for="autoRewindToggle"><b>Auto rewind</b></label>
      </div>
    </div>

    <div class="hint">
      IC thresholds: IC1 0.14–2, IC2 &gt;2–9, IC3 &gt;9–25, IC4 &gt;25–40, IC5 &gt;40–55, IC6 &gt;55–76, IC7 &gt;76 kPa.
      <br>
      Engineering-like effects: glass shards intensity and collapse severity are mapped continuously from Po(R), while the base color texture still follows IC1–IC7.
      <br>
      Nearest building triggers first when shockwave reaches it; severity uses Po(R) interpolated from CSV.
    </div>
  </div>

  <div id="scene">
    <div id="explosion"></div>
    <div id="ground"></div>

    <div class="building small" id="bSmall">
      <div class="effect-label" id="lSmall"></div>
      <div class="rubble"></div>
    </div>
    <div class="building medium" id="bMedium">
      <div class="effect-label" id="lMedium"></div>
      <div class="rubble"></div>
    </div>
    <div class="building tall" id="bTall">
      <div class="effect-label" id="lTall"></div>
      <div class="rubble"></div>
    </div>
  </div>

  <div style="text-align:center; margin-top:16px; font-family:sans-serif;">
    <div style="font-size:1.05em; max-width:900px; margin: 0 auto;" id="caption">
      Start runs. Stop freezes. Start again resumes from freeze.
    </div>
    <div class="credit">Design by Virda NL - https://www.virdapark.my.id/</div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <script>
    /* ===================== WINDOWS ===================== */
    function addWindows(buildingId, nRows, nCols, size) {
      const b = document.getElementById(buildingId);
      Array.from(b.children).forEach(child => {
        if (!child.classList.contains("effect-label") && !child.classList.contains("rubble")) child.remove();
      });

      for (let r = 0; r < nRows; r++) {
        for (let c = 0; c < nCols; c++) {
          const w = document.createElement('div');
          w.className = 'window';
          w.style.width = size + 'px';
          w.style.height = size + 'px';
          w.style.left = (5 + c * (size + 4)) + 'px';
          w.style.bottom = (6 + r * (size + 7)) + 'px';
          w.dataset.row = r;
          w.dataset.col = c;
          b.appendChild(w);
        }
      }
    }
    addWindows('bSmall',  2, 2, 10);
    addWindows('bMedium', 3, 3, 11);
    addWindows('bTall',  10, 3, 11);

    /* ===================== CSV STORAGE ===================== */
    let simRows = [];
    let hasCSV = false;

    const statusEl = document.getElementById('status');
    const csvInput = document.getElementById('csvInput');
    const modelSel = document.getElementById('modelSel');

    function toNum(v) {
      const x = Number(String(v ?? '').trim());
      return Number.isFinite(x) ? x : NaN;
    }

    function getPoFromRow(r) {
      const mode = modelSel.value;
      if (mode === "follow_csv") {
        const m = String(r.poModel || "").toLowerCase();
        if (m.includes("crowl")) return r.po_crowl;
        if (m.includes("alonso")) return r.po_alonso;
        if (m.includes("sad")) return r.po_sadovski;
        return r.po_crowl;
      }
      if (mode === "crowl") return r.po_crowl;
      if (mode === "alonso") return r.po_alonso;
      if (mode === "sadovski") return r.po_sadovski;
      return r.po_crowl;
    }

    function PoAtDistance(Rm) {
      if (!simRows.length) return NaN;
      const R = Math.max(0, Rm);

      const R0 = simRows[0].dist;
      const Rn = simRows[simRows.length - 1].dist;

      if (R <= R0) return getPoFromRow(simRows[0]);
      if (R >= Rn) return getPoFromRow(simRows[simRows.length - 1]);

      let lo = 0, hi = simRows.length - 1;
      while (hi - lo > 1) {
        const mid = (lo + hi) >> 1;
        if (R >= simRows[mid].dist) lo = mid;
        else hi = mid;
      }

      const a = simRows[lo], b = simRows[hi];
      const Ra = a.dist, Rb = b.dist;
      const Pa = getPoFromRow(a), Pb = getPoFromRow(b);
      if (!Number.isFinite(Pa) || !Number.isFinite(Pb) || Rb === Ra) return Pa;
      const t = (R - Ra) / (Rb - Ra);
      return Pa + t * (Pb - Pa);
    }

    // fallback demo curve
    function demoPoAtDistance(Rm) {
      const R = Math.max(0.1, Rm);
      return 2500 / (R * R + 4);
    }
    function PoAt(Rm) {
      return hasCSV ? PoAtDistance(Rm) : demoPoAtDistance(Rm);
    }

    csvInput.addEventListener('change', (e) => {
      const file = e.target.files?.[0];
      if (!file) return;

      statusEl.textContent = "Loading CSV...";
      Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        complete: (res) => {
          const data = res.data || [];
          const cleaned = data.map(r => ({
            dist: toNum(r.dist ?? r.distance ?? r.R ?? r.r),
            po_crowl: toNum(r.po_crowl ?? r.Po_crowl ?? r.PoCrowl),
            po_alonso: toNum(r.po_alonso ?? r.Po_alonso ?? r.PoAlonso),
            po_sadovski: toNum(r.po_sadovski ?? r.Po_sadovski ?? r.PoSadovski),
            poModel: (r.poModel ?? r.model ?? r.PoModel ?? "")
          })).filter(r => Number.isFinite(r.dist));

          cleaned.sort((a, b) => a.dist - b.dist);

          const hasAnyPo = cleaned.some(r =>
            Number.isFinite(r.po_crowl) || Number.isFinite(r.po_alonso) || Number.isFinite(r.po_sadovski)
          );

          if (!cleaned.length || !hasAnyPo) {
            simRows = [];
            hasCSV = false;
            statusEl.textContent = "CSV invalid";
            return;
          }

          simRows = cleaned;
          hasCSV = true;
          statusEl.textContent = `CSV loaded (${simRows.length} rows)`;
          updateCaption();
        },
        error: () => {
          simRows = [];
          hasCSV = false;
          statusEl.textContent = "CSV parse error";
          updateCaption();
        }
      });
    });

    /* ===================== IC CLASSIFICATION ===================== */
    function ICfromPo(Po) {
      const p = Math.max(0, Po || 0);
      if (p < 0.14) return { ic: "Below IC1", text: "Below IC1 (Very Low)" };
      if (p <= 2)   return { ic: "IC1", text: "IC1 Insignificant" };
      if (p <= 9)   return { ic: "IC2", text: "IC2 Minor" };
      if (p <= 25)  return { ic: "IC3", text: "IC3 Moderate" };
      if (p <= 40)  return { ic: "IC4", text: "IC4 Serious" };
      if (p <= 55)  return { ic: "IC5", text: "IC5 Severe" };
      if (p <= 76)  return { ic: "IC6", text: "IC6 Major" };
      return         { ic: "IC7", text: "IC7 Catastrophic" };
    }

    function showLabel(id, text) {
      const l = document.getElementById(id);
      l.textContent = text;
      l.classList.add('show-label');
      setTimeout(() => l.classList.remove('show-label'), 2400);
    }

    function crackWindows(buildingEl, level) {
      const wins = Array.from(buildingEl.querySelectorAll('.window'));
      if (!wins.length) return;

      const isTall = buildingEl.id === 'bTall';
      const nRows = isTall ? 10 : (buildingEl.id === 'bMedium' ? 3 : 2);
      const nCols = isTall ? 3  : (buildingEl.id === 'bMedium' ? 3 : 2);

      const maxCrack = wins.length;
      const crackCount =
        level === 1 ? Math.min(4, maxCrack) :
        level === 2 ? Math.min(8, maxCrack) :
        level === 3 ? Math.min(14, maxCrack) :
                      Math.min(20, maxCrack);

      let cracked = 0;
      for (let r = nRows - 1; r >= 0; r--) {
        for (let c = 0; c < nCols; c++) {
          const idx = r * nCols + c;
          const w = wins[idx];
          if (!w) continue;
          if (cracked < crackCount) {
            w.classList.add('broken', 'cracked');
            if (level >= 3) w.classList.add('framebroken');
            cracked++;
          }
        }
      }
    }

    /* ===================== CONTINUOUS Po EFFECTS (ENGINEERING-LIKE) ===================== */
    function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
    function lerp(a, b, t){ return a + (b - a) * t; }
    function smoothstep(e0, e1, x){
      const t = clamp((x - e0) / (e1 - e0), 0, 1);
      return t * t * (3 - 2 * t);
    }

    // continuous mapping:
    // - glass shards start around 9 kPa and saturate near 76 kPa
    // - collapse/rubble start around 55 kPa and saturate near 100 kPa
    function effectsFromPo(Po){
      const p = Math.max(0, Po || 0);

      const tg = smoothstep(9, 76, p);
      const nShards = Math.round(lerp(0, 28, tg));
      const spread  = Math.round(lerp(70, 190, tg));

      const tc = smoothstep(55, 100, p);

      return { nShards, spread, collapseT: tc };
    }

    function spawnGlass(buildingEl, intensity=6, spreadPx=90){
      const scene = document.getElementById('scene');
      const sRect = scene.getBoundingClientRect();

      const wins = Array.from(buildingEl.querySelectorAll('.window'));
      const useWins = wins.length > 0;

      for (let i = 0; i < intensity; i++){
        const shard = document.createElement('div');
        shard.className = 'glassShard';

        let x, y;
        if (useWins){
          const w = wins[Math.floor(Math.random()*wins.length)];
          const wRect = w.getBoundingClientRect();
          x = (wRect.left - sRect.left) + (Math.random()*6 - 3);
          y = (wRect.top  - sRect.top)  + (Math.random()*6 - 3);
        } else {
          const bRect = buildingEl.getBoundingClientRect();
          const baseX = bRect.left - sRect.left;
          const baseY = bRect.top  - sRect.top;
          x = baseX + 10 + Math.random()*(bRect.width - 20);
          y = baseY + 8  + Math.random()*(bRect.height - 16);
        }

        shard.style.left = x + 'px';
        shard.style.top  = y + 'px';

        const dx = (Math.random()*2 - 1) * spreadPx;
        const dy = 140 + Math.random()*160;
        const rot = (Math.random()*420 - 210) + 'deg';

        shard.style.setProperty('--dx', dx.toFixed(1) + 'px');
        shard.style.setProperty('--dy', dy.toFixed(1) + 'px');
        shard.style.setProperty('--rot', rot);

        const w0 = 4 + Math.random()*5;
        const h0 = 6 + Math.random()*10;
        shard.style.width  = w0.toFixed(0) + 'px';
        shard.style.height = h0.toFixed(0) + 'px';
        shard.style.opacity = (0.75 + Math.random()*0.25).toFixed(2);

        scene.appendChild(shard);
        shard.style.animation = `glassFall ${700 + Math.random()*800}ms ease-in forwards`;
        shard.addEventListener('animationend', () => shard.remove(), { once:true });
      }
    }

    // 3–5 burst steps over ~1 second (super realistic shatter train)
    function spawnGlassBurst(buildingEl, totalShards, spreadPx, burstMs = 1000){
      const n = Math.max(0, Math.round(totalShards || 0));
      if (n <= 0) return;

      const bursts = clamp(Math.round(lerp(3, 5, clamp(n / 28, 0, 1))), 3, 5);

      const weights = [];
      for (let i = 0; i < bursts; i++){
        weights.push(Math.max(0.35, 1.0 - i * 0.18));
      }
      const wSum = weights.reduce((a,b) => a + b, 0);

      let assigned = 0;
      const perBurst = weights.map((w, i) => {
        const k = (i === bursts - 1) ? (n - assigned) : Math.max(0, Math.round((w / wSum) * n));
        assigned += k;
        return k;
      });

      for (let i = 0; i < bursts; i++){
        const baseT = (i / (bursts - 1)) * burstMs;
        const jitter = (Math.random() * 90) - 45;
        const t = Math.max(0, Math.round(baseT + jitter));

        setTimeout(() => {
          const spreadI = Math.round(spreadPx * (0.92 + 0.22 * (i / (bursts - 1))));
          spawnGlass(buildingEl, perBurst[i], spreadI);
        }, t);
      }
    }

    // limiter to prevent repeated burst stacking when events fire very close
    function canBurst(buildingEl, cooldownMs = 650){
      const now = performance.now();
      const last = Number(buildingEl.dataset.lastBurstTs || 0);
      if (now - last < cooldownMs) return false;
      buildingEl.dataset.lastBurstTs = String(now);
      return true;
    }

    function applyCollapseContinuous(buildingEl, collapseT){
      const rubble = buildingEl.querySelector('.rubble');

      buildingEl.classList.remove('collapse6','collapse7','disappear');

      if (rubble){
        if (collapseT > 0.05) rubble.classList.add('show');
        else rubble.classList.remove('show');
        rubble.style.opacity = String(clamp(0.25 + 0.75*collapseT, 0, 1));
      }

      if (collapseT <= 0.05){
        buildingEl.style.transform = '';
        return;
      }

      if (collapseT <= 0.55){
        buildingEl.classList.add('collapse6');
        const t = (collapseT - 0.05) / 0.50;
        const rot = lerp(-4, -10, t);
        buildingEl.style.transform = `rotate(${rot.toFixed(1)}deg) skewX(-2deg)`;
      } else {
        buildingEl.classList.add('collapse7');
        const t = (collapseT - 0.55) / 0.45;
        const rot = lerp(-12, -22, t);
        const scaleY = lerp(0.78, 0.60, t);
        buildingEl.style.transform = `rotate(${rot.toFixed(1)}deg) skewX(-6deg) scaleY(${scaleY.toFixed(2)})`;
        if (collapseT > 0.88) buildingEl.classList.add('disappear');
      }
    }

    function clearFallingGlass(buildingEl){
      const rubble = buildingEl.querySelector('.rubble');
      if (rubble){
        rubble.classList.remove('show');
        rubble.style.opacity = '';
      }
      buildingEl.classList.remove('collapse6','collapse7','disappear');
      buildingEl.style.transform = '';
      delete buildingEl.dataset.lastBurstTs;
    }

    function clearDamageClasses(buildingEl){
      buildingEl.classList.remove('dIC1','dIC2','dIC3','dIC4','dIC5','dIC6','dIC7','hit');
      buildingEl.querySelectorAll('.window').forEach(w => {
        w.classList.remove('broken','cracked','framebroken');
      });
      clearFallingGlass(buildingEl);
    }

    function applyDamageFromSimulation(buildingEl, labelId, Rm){
      let Po = PoAt(Rm);
      if (!Number.isFinite(Po)) Po = 0;

      const ic = ICfromPo(Po);
      clearDamageClasses(buildingEl);

      // base shake
      buildingEl.classList.add('hit');

      // base building/texture uses IC categories (discrete)
      if (ic.ic === "IC1") { buildingEl.classList.add('dIC1'); crackWindows(buildingEl, 1); }
      else if (ic.ic === "IC2") { buildingEl.classList.add('dIC2'); crackWindows(buildingEl, 1); }
      else if (ic.ic === "IC3") { buildingEl.classList.add('dIC3'); crackWindows(buildingEl, 2); }
      else if (ic.ic === "IC4") { buildingEl.classList.add('dIC4'); crackWindows(buildingEl, 2); }
      else if (ic.ic === "IC5") { buildingEl.classList.add('dIC5'); crackWindows(buildingEl, 3); }
      else if (ic.ic === "IC6") { buildingEl.classList.add('dIC6'); crackWindows(buildingEl, 4); }
      else if (ic.ic === "IC7") { buildingEl.classList.add('dIC7'); crackWindows(buildingEl, 4); }
      else { crackWindows(buildingEl, 1); }

      // continuous effects mapped from Po
      const fx = effectsFromPo(Po);

      // realistic staged shards: 3–5 bursts in ~1s
      if (fx.nShards > 0 && canBurst(buildingEl)) {
        spawnGlassBurst(buildingEl, fx.nShards, fx.spread, 1000);
      }

      // continuous collapse + rubble (starts ~55 kPa)
      applyCollapseContinuous(buildingEl, fx.collapseT);

      showLabel(labelId, `${ic.text} | R≈${Rm.toFixed(1)} m | Po≈${Po.toFixed(2)} kPa`);
    }

    /* ===================== TIMING + RESUME STATE ===================== */
    let waveElem = null;
    let waveAnim = null;
    let waveDurationMs = 3400;

    let isRunning = false;
    let isPaused = false;
    let elapsedMs = 0;

    let timers = [];
    let buildingEvents = [];
    let endEvent = { tEnd: 0, fired: false };

    const autoRewindToggle = document.getElementById('autoRewindToggle');
    const startBtn = document.getElementById('startBtn');
    const stopBtn  = document.getElementById('stopBtn');

    function clearAllTimers(){
      for (const t of timers) clearTimeout(t);
      timers = [];
    }

    function getPxToMeter(){
      const maxPx = 900;
      let maxDist = 200;
      if (hasCSV && simRows.length) maxDist = simRows[simRows.length - 1].dist;
      return maxDist / maxPx;
    }

    const WAVE_ORIGIN_X = 125;
    function buildingDistancePx(buildingEl){
      const left = parseFloat(getComputedStyle(buildingEl).left);
      const width = parseFloat(getComputedStyle(buildingEl).width);
      const centerX = left + width / 2;
      return Math.max(0, centerX - WAVE_ORIGIN_X);
    }
    function buildingDistanceM(buildingEl){
      return buildingDistancePx(buildingEl) * getPxToMeter();
    }

    function createOrReuseWave(fromScratch){
      if (fromScratch){
        if (waveElem) waveElem.remove();
        waveElem = document.createElement('div');
        waveElem.className = 'wave';
        document.getElementById('scene').appendChild(waveElem);

        waveDurationMs = Math.max(800, toNum(document.getElementById('waveMs').value) || 3400);

        waveAnim = waveElem.animate([
          { width: '40px',  height: '40px',  marginLeft: '-20px',  marginBottom: '-20px',  opacity: 0.85, offset: 0 },
          { opacity: 0.96, offset: 0.10 },
          { opacity: 0.65, offset: 0.60 },
          { opacity: 0.22, offset: 0.90 },
          { width: '900px', height: '900px', marginLeft: '-450px', marginBottom: '-450px', opacity: 0.0, offset: 1 }
        ], {
          duration: waveDurationMs,
          easing: 'cubic-bezier(.72,-0.03,.39,1.13)',
          fill: 'forwards'
        });

        waveAnim.pause();
      }

      if (waveAnim){
        waveAnim.currentTime = Math.max(0, Math.min(waveDurationMs, elapsedMs));
      }
    }

    function buildScheduleFromScratch(){
      const buildings = [
        { el: document.getElementById('bSmall'),  labelId: 'lSmall'  },
        { el: document.getElementById('bMedium'), labelId: 'lMedium' },
        { el: document.getElementById('bTall'),   labelId: 'lTall'   },
      ].map(b => {
        b.Rpx = buildingDistancePx(b.el);
        b.Rm  = buildingDistanceM(b.el);
        return b;
      }).sort((a,b) => a.Rpx - b.Rpx);

      buildingEvents = buildings.map(b => {
        const tHit = Math.max(200, Math.min(waveDurationMs - 150, (b.Rpx / 900) * waveDurationMs));
        return { tHit, fired: false, el: b.el, labelId: b.labelId, Rm: b.Rm };
      });

      endEvent = { tEnd: waveDurationMs + 800, fired: false };
    }

    function schedulePendingEvents(){
      clearAllTimers();

      for (const ev of buildingEvents){
        if (ev.fired) continue;
        const delay = ev.tHit - elapsedMs;
        if (delay <= 0){
          ev.fired = true;
          applyDamageFromSimulation(ev.el, ev.labelId, ev.Rm);
        } else {
          timers.push(setTimeout(() => {
            if (!isRunning) return;
            ev.fired = true;
            applyDamageFromSimulation(ev.el, ev.labelId, ev.Rm);
          }, delay));
        }
      }

      if (!endEvent.fired){
        const endDelay = endEvent.tEnd - elapsedMs;
        if (endDelay <= 0){
          endEvent.fired = true;
          onRunFinished();
        } else {
          timers.push(setTimeout(() => {
            if (!isRunning) return;
            endEvent.fired = true;
            onRunFinished();
          }, endDelay));
        }
      }
    }

    function updateCaption(){
      const caption = document.getElementById('caption');
      caption.innerHTML =
        (hasCSV
          ? 'CSV-driven: nearest building triggers first when wave reaches it; IC base + continuous Po-based glass/collapse effects.'
          : 'No CSV loaded: demo curve used. Import CSV for simulation-driven IC + Po-based effects.'
        ) + `<br>Auto rewind: <b>${autoRewindToggle.checked ? "ON" : "OFF"}</b> · Mode: <b>${isPaused ? "Paused" : (isRunning ? "Running" : "Idle")}</b>`;
    }

    function startBlast(){
      // RESUME
      if (isPaused && waveAnim){
        isRunning = true;
        isPaused = false;

        startBtn.disabled = true;
        stopBtn.disabled = false;

        updateCaption();
        waveAnim.play();
        schedulePendingEvents();
        return;
      }

      // START NEW
      if (isRunning) return;

      isRunning = true;
      isPaused = false;
      elapsedMs = 0;

      startBtn.disabled = true;
      stopBtn.disabled = false;

      resetScene(false);
      createOrReuseWave(true);
      buildScheduleFromScratch();

      updateCaption();
      waveAnim.play();
      schedulePendingEvents();
    }

    function stopBlast(){
      if (!isRunning) return;

      isRunning = false;
      isPaused = true;

      if (waveAnim){
        elapsedMs = Math.max(0, Math.min(waveDurationMs, waveAnim.currentTime || 0));
        waveAnim.pause();
      }

      clearAllTimers();

      startBtn.disabled = false;
      stopBtn.disabled = true;

      document.getElementById('caption').innerHTML =
        `Stopped (freeze). Press Start to resume from ${elapsedMs.toFixed(0)} ms. Auto rewind: <b>${autoRewindToggle.checked ? "ON" : "OFF"}</b>`;
    }

    function onRunFinished(){
      if (autoRewindToggle.checked){
        isRunning = false;
        isPaused = false;
        elapsedMs = 0;

        isRunning = true;
        startBtn.disabled = true;
        stopBtn.disabled = false;

        resetScene(false);
        createOrReuseWave(true);
        buildScheduleFromScratch();
        updateCaption();

        waveAnim.play();
        schedulePendingEvents();
      } else {
        isRunning = false;
        isPaused = false;

        startBtn.disabled = false;
        stopBtn.disabled = true;

        document.getElementById('caption').innerHTML =
          'Finished (Auto rewind OFF). Press Start to play again.';
      }
    }

    function resetScene(full=true){
      if (full){
        if (waveElem){ waveElem.remove(); waveElem = null; }
        waveAnim = null;
      }

      const bSmall  = document.getElementById('bSmall');   bSmall.className  = 'building small';
      const bMedium = document.getElementById('bMedium');  bMedium.className = 'building medium';
      const bTall   = document.getElementById('bTall');    bTall.className   = 'building tall';

      // reset inline transforms + rubble visibility
      [bSmall,bMedium,bTall].forEach(b => {
        b.style.transform = '';
        clearFallingGlass(b);
      });

      ['lSmall','lMedium','lTall'].forEach(id => {
        const l = document.getElementById(id);
        l.textContent = "";
        l.className = "effect-label";
      });

      addWindows('bSmall',  2, 2, 10);
      addWindows('bMedium', 3, 3, 11);
      addWindows('bTall',  10, 3, 11);

      clearAllTimers();

      if (full){
        isRunning = false;
        isPaused = false;
        elapsedMs = 0;
        buildingEvents = [];
        endEvent = { tEnd: 0, fired: false };

        startBtn.disabled = false;
        stopBtn.disabled = true;

        document.getElementById('caption').innerHTML =
          (hasCSV
            ? 'Reset done. CSV loaded. Press Start to run again.'
            : 'Reset done. Import CSV (recommended) or press Start to run demo.'
          );
      }

      updateCaption();
    }

    // expose to buttons
    window.startBlast = startBlast;
    window.stopBlast = stopBlast;
    window.resetScene = resetScene;

    // initial caption
    updateCaption();
  </script>
</body>
</html>
